// Copyright: Wieger Wesselink 2022 - 2024
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file multilayer_perceptron_test.cpp
/// \brief Tests for multilayer perceptrons.

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#include "doctest/doctest.h"
#include "nerva/neural_networks/multilayer_perceptron.h"
#include "nerva/neural_networks/loss_functions.h"
#include "nerva/utilities/string_utility.h"
#include <iostream>

using namespace nerva;

inline
void check_equal_matrices(const std::string& name1, const eigen::matrix& X1, const std::string& name2, const eigen::matrix& X2, scalar epsilon = 1e-5)
{
  scalar error = (X2 - X1).squaredNorm();
  if (error > epsilon)
  {
    CHECK_LE(error, epsilon);
    print_cpp_matrix(name1, X1);
    print_cpp_matrix(name2, X2);
  }
}

void construct_mlp(multilayer_perceptron& M,
                   const eigen::matrix& W1,
                   const eigen::matrix& b1,
                   const eigen::matrix& W2,
                   const eigen::matrix& b2,
                   const eigen::matrix& W3,
                   const eigen::matrix& b3,
                   std::size_t batch_size = 1
                  )
{
  std::size_t N1 = W1.cols();
  std::size_t N2 = W2.cols();
  std::size_t N3 = W3.cols();
  std::size_t N4 = W3.rows();

  auto layer1 = std::make_shared<relu_layer<eigen::matrix>>(N1, N2, batch_size);
  M.layers.push_back(layer1);
  layer1->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer1->W, layer1->DW, layer1->b, layer1->Db);
  layer1->W = W1;
  layer1->b = b1;

  auto layer2 = std::make_shared<relu_layer<eigen::matrix>>(N2, N3, batch_size);
  M.layers.push_back(layer2);
  layer2->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer2->W, layer2->DW, layer2->b, layer2->Db);
  layer2->W = W2;
  layer2->b = b2;

  auto layer3 = std::make_shared<linear_layer<eigen::matrix>>(N3, N4, batch_size);
  M.layers.push_back(layer3);
  layer3->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer3->W, layer3->DW, layer3->b, layer3->Db);
  layer3->W = W3;
  layer3->b = b3;
}

void test_mlp_execution(const eigen::matrix& X,
                        const eigen::matrix& T,
                        const eigen::matrix& W1,
                        const eigen::matrix& b1,
                        const eigen::matrix& W2,
                        const eigen::matrix& b2,
                        const eigen::matrix& W3,
                        const eigen::matrix& b3,
                        const eigen::matrix& Y1,
                        const eigen::matrix& DY1,
                        const eigen::matrix& Y2,
                        const eigen::matrix& DY2,
                        scalar lr
                       )
{
  multilayer_perceptron M;
  std::size_t K = W3.cols(); // the output size of the MLP
  std::size_t N = X.rows();  // the number of examples in the dataset
  std::size_t batch_size = N;
  construct_mlp(M, W1, b1, W2, b2, W3, b3, batch_size);

  eigen::matrix Y(K, N);
  eigen::matrix DY(K, N);

  softmax_cross_entropy_loss loss;

  M.feedforward(X, Y);
  DY = loss.gradient(Y, T) / N; // take the average of the gradients in the batch

  check_equal_matrices("Y", Y, "Y1", Y1);
  check_equal_matrices("DY", DY, "DY1", DY1);

  M.backpropagate(Y, DY);
  M.optimize(lr);
  M.feedforward(X, Y);
  M.backpropagate(Y, DY);

  check_equal_matrices("Y", Y, "Y2", Y2);
  check_equal_matrices("DY", DY, "DY2", DY2);
}

//--- begin generated code ---//
TEST_CASE("test_mlp1")
{
  eigen::matrix X {    {0.37454012, 0.95071429},
    {0.73199391, 0.59865850},
    {0.15601864, 0.15599452},
    {0.05808361, 0.86617613},
    {0.60111499, 0.70807260},
  };

  eigen::matrix T {    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {    {-0.21145512, -0.23963138},
    {-0.68665254, -0.31973946},
    {-0.48985013, -0.61555690},
    {-0.02011989, -0.14331175},
    {-0.37267196, 0.52824616},
    {-0.00218203, -0.34701961},
  };

  eigen::matrix b1 {    {-0.19969320, 0.32225430, -0.39840436, 0.02031866, -0.55133241, 0.38915542},
  };

  eigen::matrix W2 {    {0.19979259, 0.11244299, -0.14483851, -0.20240757, 0.40738514, -0.15628406},
    {-0.03180553, -0.17497963, -0.08604460, 0.24243671, 0.09465710, -0.11147831},
    {-0.30460498, 0.02003654, 0.13813639, -0.05041482, 0.37746599, 0.21138696},
    {0.13889015, 0.07679792, 0.11664709, -0.30111945, -0.05145215, 0.30647761},
  };

  eigen::matrix b2 {    {-0.32005355, -0.23848130, -0.19684513, 0.08632692},
  };

  eigen::matrix W3 {    {0.35909218, -0.37359810, 0.10093290, 0.32086837},
    {-0.42879087, -0.39703828, -0.28162760, -0.29467630},
    {-0.49876362, 0.47439390, 0.45686680, -0.29186702},
  };

  eigen::matrix b3 {    {-0.46912575, -0.16678143, -0.30444700},
  };

  eigen::matrix Y1 {    {-0.43568105, -0.19749609, -0.33486882},
    {-0.42374364, -0.20845905, -0.34572729},
    {-0.40444189, -0.22618520, -0.36328447},
    {-0.43259466, -0.20033053, -0.33767626},
    {-0.42744938, -0.20505580, -0.34235650},
  };

  eigen::matrix DY1 {    {0.05925904, -0.12480360, 0.06554459},
    {-0.13978362, 0.07468125, 0.06510236},
    {0.06178278, -0.12616143, 0.06437864},
    {0.05950571, -0.12493636, 0.06543064},
    {0.05991826, -0.12515834, 0.06524009},
  };

  eigen::matrix Y2 {    {-0.43693548, -0.19295722, -0.33795971},
    {-0.42499915, -0.20390208, -0.34883845},
    {-0.40571138, -0.22158773, -0.36641729},
    {-0.43385389, -0.19578284, -0.34076825},
    {-0.42870468, -0.20050436, -0.34546125},
  };

  eigen::matrix DY2 {    {0.05916537, -0.12448626, 0.06532091},
    {-0.13987820, 0.07499861, 0.06487960},
    {0.06168574, -0.12584360, 0.06415787},
    {0.05941144, -0.12461881, 0.06520736},
    {0.05982394, -0.12484097, 0.06501704},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp2")
{
  eigen::matrix X {    {0.00077877, 0.99221158, 0.61748153},
    {0.61165315, 0.00706631, 0.02306242},
    {0.52477467, 0.39986098, 0.04666566},
    {0.97375554, 0.23277134, 0.09060644},
  };

  eigen::matrix T {    {0.00000000, 1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {    {-0.57696527, -0.37256593, -0.03110080},
    {-0.55260462, 0.18460992, -0.10590127},
    {0.10636798, -0.38558820, -0.25476536},
    {-0.04637986, -0.16362157, -0.28163731},
    {-0.46343166, 0.56671232, 0.56575149},
  };

  eigen::matrix b1 {    {0.44730583, -0.29515237, 0.00021522, 0.39794335, -0.50365335},
  };

  eigen::matrix W2 {    {0.23181717, -0.33412707, 0.15718168, 0.14581251, -0.10755118},
    {0.34673068, 0.08789898, -0.26765490, 0.40125751, -0.14955465},
  };

  eigen::matrix b2 {    {0.32063779, 0.23229931},
  };

  eigen::matrix W3 {    {0.31125659, 0.03687588},
    {0.17496572, -0.05447505},
    {-0.00810813, 0.13208316},
    {-0.07162435, 0.01159831},
  };

  eigen::matrix b3 {    {0.33034673, 0.60422236, -0.01450147, 0.14723538},
  };

  eigen::matrix Y1 {    {0.43145591, 0.64480078, 0.01162641, 0.12831059},
    {0.47044232, 0.65334910, 0.03425841, 0.12290906},
    {0.45646939, 0.64874643, 0.02886948, 0.12525597},
    {0.45611674, 0.64872503, 0.02856586, 0.12528990},
  };

  eigen::matrix DY1 {    {0.06880490, -0.16483250, 0.04521576, 0.05081186},
    {0.07035060, 0.08447014, -0.20451842, 0.04969767},
    {0.06979087, 0.08458698, 0.04550870, -0.19988653},
    {0.06977702, 0.08459820, -0.20449811, 0.05012289},
  };

  eigen::matrix Y2 {    {0.42783475, 0.64343989, 0.01550637, 0.12899204},
    {0.46652353, 0.65180612, 0.03852256, 0.12366116},
    {0.45264399, 0.64725971, 0.03301890, 0.12598616},
    {0.45229718, 0.64724058, 0.03271303, 0.12601903},
  };

  eigen::matrix DY2 {    {0.06859849, -0.16489586, 0.04541953, 0.05087785},
    {0.07012416, 0.08439853, -0.20429231, 0.04976963},
    {0.06957068, 0.08451752, 0.04572833, -0.19981655},
    {0.06955715, 0.08452878, -0.20427869, 0.05019275},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp3")
{
  eigen::matrix X {    {0.98323089, 0.46676290, 0.85994041, 0.68030757, 0.45049927, 0.01326496},
    {0.94220173, 0.56328821, 0.38541651, 0.01596625, 0.23089382, 0.24102546},
    {0.68326354, 0.60999668, 0.83319491, 0.17336465, 0.39106062, 0.18223609},
    {0.75536144, 0.42515588, 0.20794167, 0.56770033, 0.03131329, 0.84228480},
    {0.44975412, 0.39515024, 0.92665887, 0.72727197, 0.32654077, 0.57044399},
    {0.52083427, 0.96117204, 0.84453386, 0.74732012, 0.53969210, 0.58675116},
    {0.96525532, 0.60703427, 0.27599919, 0.29627350, 0.16526695, 0.01563641},
    {0.42340147, 0.39488152, 0.29348817, 0.01407982, 0.19884241, 0.71134198},
  };

  eigen::matrix T {    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
  };

  eigen::matrix W1 {    {0.38785392, 0.07309578, -0.22078086, 0.03878920, 0.28372014, -0.38752007},
    {-0.21399581, -0.22889234, 0.09480271, -0.03475436, -0.39457920, -0.20743400},
  };

  eigen::matrix b1 {    {0.39862320, -0.16680227},
  };

  eigen::matrix W2 {    {-0.52632856, 0.13611974},
    {0.44118527, -0.17678487},
  };

  eigen::matrix b2 {    {0.64002031, -0.52457136},
  };

  eigen::matrix W3 {    {0.40196484, -0.63122964},
    {0.08181032, -0.12489266},
    {-0.18747795, 0.49713352},
  };

  eigen::matrix b3 {    {0.26868016, 0.08766443, -0.04747497},
  };

  eigen::matrix Y1 {    {0.36234277, 0.10672721, -0.09115957},
    {0.37935889, 0.11019044, -0.09909595},
    {0.40507403, 0.11542414, -0.11108960},
    {0.44528365, 0.12360784, -0.12984352},
    {0.46307796, 0.12722945, -0.13814285},
    {0.43303403, 0.12111473, -0.12413025},
    {0.35484004, 0.10520022, -0.08766028},
    {0.46073896, 0.12675339, -0.13705193},
  };

  eigen::matrix DY1 {    {0.05187070, 0.04017073, -0.09204142},
    {-0.07256172, 0.04006361, 0.03249811},
    {0.05329737, 0.03989445, -0.09319182},
    {-0.07035678, 0.03961269, 0.03074409},
    {0.05523950, -0.08551860, 0.03027909},
    {0.05423295, 0.03970072, -0.09393368},
    {0.05162069, -0.08478329, 0.03316259},
    {-0.06983890, 0.03949889, 0.03034000},
  };

  eigen::matrix Y2 {    {0.36119008, 0.10585559, -0.08958054},
    {0.37831956, 0.10933092, -0.09755698},
    {0.40399396, 0.11453991, -0.10951245},
    {0.44430482, 0.12271844, -0.12828347},
    {0.46202135, 0.12631287, -0.13653326},
    {0.43191922, 0.12020557, -0.12251602},
    {0.35377416, 0.10435100, -0.08612727},
    {0.45980108, 0.12586240, -0.13549937},
  };

  eigen::matrix DY2 {    {0.05182863, 0.04014943, -0.09197807},
    {-0.07259991, 0.04004163, 0.03255828},
    {0.05325799, 0.03987277, -0.09313076},
    {-0.07039247, 0.03959035, 0.03080212},
    {0.05520136, -0.08554033, 0.03033897},
    {0.05419261, 0.03967935, -0.09387195},
    {0.05158149, -0.08480512, 0.03322363},
    {-0.06987308, 0.03947626, 0.03039681},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}


//--- end generated code ---//
