// Copyright: Wieger Wesselink 2022 - 2024
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file multilayer_perceptron_test.cpp
/// \brief Tests for multilayer perceptrons.

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#include "doctest/doctest.h"
#include "nerva/neural_networks/multilayer_perceptron.h"
#include "nerva/neural_networks/loss_functions.h"
#include "nerva/utilities/string_utility.h"
#include <iostream>

using namespace nerva;

inline
void check_equal_matrices(const std::string& name1, const eigen::matrix& X1, const std::string& name2, const eigen::matrix& X2, scalar epsilon = 1e-5)
{
  scalar error = (X2 - X1).squaredNorm();
  if (error > epsilon)
  {
    CHECK_LE(error, epsilon);
    print_cpp_matrix(name1, X1);
    print_cpp_matrix(name2, X2);
  }
}

void construct_mlp(multilayer_perceptron& M,
                   const eigen::matrix& W1,
                   const eigen::matrix& b1,
                   const eigen::matrix& W2,
                   const eigen::matrix& b2,
                   const eigen::matrix& W3,
                   const eigen::matrix& b3,
                   const std::vector<long>& sizes,
                   long N
                  )
{
  long batch_size = N;

  auto layer1 = std::make_shared<relu_layer<eigen::matrix>>(sizes[0], sizes[1], batch_size);
  M.layers.push_back(layer1);
  layer1->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer1->W, layer1->DW, layer1->b, layer1->Db);
  layer1->W = W1;
  layer1->b = b1;

  auto layer2 = std::make_shared<relu_layer<eigen::matrix>>(sizes[1], sizes[2], batch_size);
  M.layers.push_back(layer2);
  layer2->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer2->W, layer2->DW, layer2->b, layer2->Db);
  layer2->W = W2;
  layer2->b = b2;

  auto layer3 = std::make_shared<linear_layer<eigen::matrix>>(sizes[2], sizes[3], batch_size);
  M.layers.push_back(layer3);
  layer3->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer3->W, layer3->DW, layer3->b, layer3->Db);
  layer3->W = W3;
  layer3->b = b3;
}

void test_mlp_execution(const eigen::matrix& X,
                        const eigen::matrix& T,
                        const eigen::matrix& W1,
                        const eigen::matrix& b1,
                        const eigen::matrix& W2,
                        const eigen::matrix& b2,
                        const eigen::matrix& W3,
                        const eigen::matrix& b3,
                        const eigen::matrix& Y1,
                        const eigen::matrix& DY1,
                        const eigen::matrix& Y2,
                        const eigen::matrix& DY2,
                        scalar lr,
                        const std::vector<long>& sizes,
                        long N
                       )
{
  multilayer_perceptron M;
  long K = sizes.back(); // the output size of the MLP
  construct_mlp(M, W1, b1, W2, b2, W3, b3, sizes, N);

  eigen::matrix Y(N, K);
  eigen::matrix DY(N, K);

  softmax_cross_entropy_loss loss;

  M.feedforward(X, Y);
  DY = loss.gradient(Y, T) / N; // take the average of the gradients in the batch

  check_equal_matrices("Y", Y, "Y1", Y1);
  check_equal_matrices("DY", DY, "DY1", DY1);

  M.backpropagate(Y, DY);
  M.optimize(lr);
  M.feedforward(X, Y);
  M.backpropagate(Y, DY);

  check_equal_matrices("Y", Y, "Y2", Y2);
  check_equal_matrices("DY", DY, "DY2", DY2);
}

//--- begin generated code ---//
TEST_CASE("test_mlp1")
{
  eigen::matrix X {
    {0.37454012, 0.95071429},
    {0.73199391, 0.59865850},
    {0.15601864, 0.15599452},
    {0.05808361, 0.86617613},
    {0.60111499, 0.70807260},
  };

  eigen::matrix T {
    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {
    {0.49533969, -0.17717211},
    {-0.06629792, -0.12774642},
    {0.07197830, 0.00892173},
    {0.56779718, -0.29337478},
    {0.50706112, 0.02468743},
    {-0.05462257, -0.26286170},
  };

  eigen::matrix b1 {
    {-0.44279799, 0.09383895, 0.51930934, -0.66277492, 0.29730681, -0.51560795},
  };

  eigen::matrix W2 {
    {-0.33926159, 0.12577672, -0.26906654, -0.24953809, 0.20983323, 0.35058898},
    {-0.01059972, -0.21300183, -0.10652732, -0.07487237, 0.35342675, -0.34640735},
    {-0.26225659, -0.12630062, 0.07536341, -0.38347977, 0.09950117, 0.18625183},
    {-0.34327471, 0.18733637, 0.07683491, -0.03865770, 0.18858312, 0.34782103},
  };

  eigen::matrix b2 {
    {-0.23771128, 0.28942898, 0.18905164, 0.25768593},
  };

  eigen::matrix W3 {
    {0.11864471, -0.03470713, -0.21211213, -0.49159104},
    {0.36983651, 0.49527365, 0.14834875, -0.44451624},
    {-0.19009131, 0.15034962, 0.26015276, -0.47494769},
  };

  eigen::matrix b3 {
    {0.49190634, -0.49408060, 0.36913675},
  };

  eigen::matrix Y1 {
    {0.22292745, -0.42512688, 0.31580961},
    {0.20004082, -0.40855044, 0.31324691},
    {0.23683202, -0.45041090, 0.30815530},
    {0.24459934, -0.44057098, 0.31829780},
    {0.20848992, -0.41465759, 0.31419605},
  };

  eigen::matrix DY1 {
    {0.07632438, -0.16007759, 0.08375322},
    {-0.12492435, 0.04084993, 0.08407443},
    {0.07761296, -0.16096371, 0.08335076},
    {0.07750477, -0.16093726, 0.08343250},
    {0.07553586, -0.15949360, 0.08395775},
  };

  eigen::matrix Y2 {
    {0.21994662, -0.41487139, 0.31037316},
    {0.19699478, -0.39797202, 0.30765328},
    {0.23398942, -0.44046587, 0.30287832},
    {0.24170950, -0.43065348, 0.31301007},
    {0.20546943, -0.40419996, 0.30866039},
  };

  eigen::matrix DY2 {
    {0.07619997, -0.15961158, 0.08341162},
    {-0.12505418, 0.04133868, 0.08371549},
    {0.07749683, -0.16052049, 0.08302368},
    {0.07738727, -0.16049375, 0.08310648},
    {0.07540813, -0.15901338, 0.08360523},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp2")
{
  eigen::matrix X {
    {0.00077877, 0.99221158, 0.61748153},
    {0.61165315, 0.00706631, 0.02306242},
    {0.52477467, 0.39986098, 0.04666566},
    {0.97375554, 0.23277134, 0.09060644},
  };

  eigen::matrix T {
    {0.00000000, 1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {
    {0.19950700, 0.40060702, -0.10286414},
    {0.23125173, -0.44931731, 0.41533926},
    {-0.07550249, -0.38783047, -0.47312999},
    {-0.30185983, -0.01912778, -0.14155971},
    {0.56579667, 0.11331680, -0.12869462},
  };

  eigen::matrix b1 {
    {-0.03569924, -0.12569955, -0.16473861, -0.16796632, -0.43319982},
  };

  eigen::matrix W2 {
    {-0.18245003, 0.16331261, 0.06287064, -0.30888668, 0.28953391},
    {-0.16330035, 0.33859047, 0.31731161, -0.30788797, 0.32257581},
  };

  eigen::matrix b2 {
    {0.11975307, -0.43411282},
  };

  eigen::matrix W3 {
    {-0.22485116, 0.67256737},
    {0.21453555, 0.28260550},
    {0.00875011, -0.43259391},
    {-0.56235409, 0.41092914},
  };

  eigen::matrix b3 {
    {0.15633471, -0.15721853, 0.21348289, 0.21536753},
  };

  eigen::matrix Y1 {
    {0.14165077, -0.14320825, 0.21405432, 0.17864290},
    {0.13215514, -0.13414825, 0.21442384, 0.15489426},
    {0.13861324, -0.14031008, 0.21417251, 0.17104602},
    {0.12953837, -0.13165155, 0.21452567, 0.14834973},
  };

  eigen::matrix DY1 {
    {0.06468482, -0.20134923, 0.06954195, 0.06712247},
    {0.06451689, 0.04943327, -0.17995094, 0.06600076},
    {0.06463207, 0.04890049, 0.06970485, -0.18323737},
    {0.06446909, 0.04964988, -0.17981230, 0.06569332},
  };

  eigen::matrix Y2 {
    {0.13884465, -0.14247814, 0.21628790, 0.17796557},
    {0.12934738, -0.13342704, 0.21667007, 0.15423605},
    {0.13581198, -0.13958795, 0.21640994, 0.17038827},
    {0.12669963, -0.13090368, 0.21677661, 0.14762047},
  };

  eigen::matrix DY2 {
    {0.06451277, -0.20130676, 0.06970739, 0.06708658},
    {0.06434402, 0.04947510, -0.17978467, 0.06596555},
    {0.06445983, 0.04894231, 0.06987027, -0.18327241},
    {0.06429543, 0.04969405, -0.17964418, 0.06565471},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp3")
{
  eigen::matrix X {
    {0.98323089, 0.46676290, 0.85994041, 0.68030757, 0.45049927, 0.01326496},
    {0.94220173, 0.56328821, 0.38541651, 0.01596625, 0.23089382, 0.24102546},
    {0.68326354, 0.60999668, 0.83319491, 0.17336465, 0.39106062, 0.18223609},
    {0.75536144, 0.42515588, 0.20794167, 0.56770033, 0.03131329, 0.84228480},
    {0.44975412, 0.39515024, 0.92665887, 0.72727197, 0.32654077, 0.57044399},
    {0.52083427, 0.96117204, 0.84453386, 0.74732012, 0.53969210, 0.58675116},
    {0.96525532, 0.60703427, 0.27599919, 0.29627350, 0.16526695, 0.01563641},
    {0.42340147, 0.39488152, 0.29348817, 0.01407982, 0.19884241, 0.71134198},
  };

  eigen::matrix T {
    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
  };

  eigen::matrix W1 {
    {0.25084189, 0.19421920, -0.14001985, -0.35766408, -0.01150930, -0.30020535},
    {-0.10845069, 0.11454272, -0.18147147, -0.12887229, -0.31075874, 0.19414420},
  };

  eigen::matrix b1 {
    {-0.11259678, 0.08564738},
  };

  eigen::matrix W2 {
    {-0.35439244, 0.47385305},
    {0.13896380, 0.39342237},
  };

  eigen::matrix b2 {
    {0.59611481, -0.00830495},
  };

  eigen::matrix W3 {
    {0.22450505, 0.41295558},
    {-0.21100920, -0.56412071},
    {-0.66648233, -0.47502354},
  };

  eigen::matrix b3 {
    {0.23557222, 0.48383039, 0.29152182},
  };

  eigen::matrix Y1 {
    {0.36940300, 0.35804468, -0.10577816},
    {0.36378995, 0.36237401, -0.08507714},
    {0.36940300, 0.35804468, -0.10577816},
    {0.39160112, 0.33204252, -0.14975241},
    {0.36940300, 0.35804468, -0.10577816},
    {0.36940300, 0.35804468, -0.10577816},
    {0.36383957, 0.36238211, -0.08545798},
    {0.39452425, 0.32854229, -0.15521815},
  };

  eigen::matrix DY1 {
    {0.04788394, 0.04734314, -0.09522709},
    {-0.07759650, 0.04733643, 0.03026007},
    {0.04788394, 0.04734314, -0.09522709},
    {-0.07547819, 0.04665847, 0.02881971},
    {0.04788394, -0.07765687, 0.02977291},
    {0.04788394, 0.04734314, -0.09522709},
    {0.04740918, -0.07765986, 0.03025067},
    {-0.07526353, 0.04656069, 0.02870284},
  };

  eigen::matrix Y2 {
    {0.36914429, 0.35643008, -0.10346460},
    {0.36422613, 0.35984835, -0.08363169},
    {0.36914429, 0.35643008, -0.10346460},
    {0.39270544, 0.32864273, -0.14945167},
    {0.36914429, 0.35643008, -0.10346460},
    {0.36914429, 0.35643008, -0.10346460},
    {0.36427569, 0.35985583, -0.08401179},
    {0.39551449, 0.32527512, -0.15469965},
  };

  eigen::matrix DY2 {
    {0.04787914, 0.04727425, -0.09515339},
    {-0.07755496, 0.04723779, 0.03031717},
    {0.04787914, 0.04727425, -0.09515339},
    {-0.07538578, 0.04653547, 0.02885030},
    {0.04787914, -0.07772575, 0.02984660},
    {0.04787914, 0.04727425, -0.09515339},
    {0.04745074, -0.07775852, 0.03030778},
    {-0.07517929, 0.04644140, 0.02873789},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}


//--- end generated code ---//
