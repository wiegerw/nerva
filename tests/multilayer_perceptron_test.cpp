// Copyright: Wieger Wesselink 2022 - 2024
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file multilayer_perceptron_test.cpp
/// \brief Tests for multilayer perceptrons.

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#include "doctest/doctest.h"
#include "nerva/neural_networks/multilayer_perceptron.h"
#include "nerva/neural_networks/loss_functions.h"
#include "nerva/utilities/string_utility.h"
#include <iostream>

using namespace nerva;

inline
void check_equal_matrices(const std::string& name1, const eigen::matrix& X1, const std::string& name2, const eigen::matrix& X2, scalar epsilon = 1e-5)
{
  scalar error = (X2 - X1).squaredNorm();
  if (error > epsilon)
  {
    CHECK_LE(error, epsilon);
    print_cpp_matrix(name1, X1);
    print_cpp_matrix(name2, X2);
  }
}

void construct_mlp(multilayer_perceptron& M,
                   const eigen::matrix& W1,
                   const eigen::matrix& b1,
                   const eigen::matrix& W2,
                   const eigen::matrix& b2,
                   const eigen::matrix& W3,
                   const eigen::matrix& b3,
                   std::size_t batch_size = 1
                  )
{
  std::size_t N1 = W1.cols();
  std::size_t N2 = W2.cols();
  std::size_t N3 = W3.cols();
  std::size_t N4 = W3.rows();

  auto layer1 = std::make_shared<relu_layer<eigen::matrix>>(N1, N2, batch_size);
  M.layers.push_back(layer1);
  layer1->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer1->W, layer1->DW, layer1->b, layer1->Db);
  layer1->W = W1;
  layer1->b = b1;

  auto layer2 = std::make_shared<relu_layer<eigen::matrix>>(N2, N3, batch_size);
  M.layers.push_back(layer2);
  layer2->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer2->W, layer2->DW, layer2->b, layer2->Db);
  layer2->W = W2;
  layer2->b = b2;

  auto layer3 = std::make_shared<linear_layer<eigen::matrix>>(N3, N4, batch_size);
  M.layers.push_back(layer3);
  layer3->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer3->W, layer3->DW, layer3->b, layer3->Db);
  layer3->W = W3;
  layer3->b = b3;
}

void test_mlp_execution(const eigen::matrix& X,
                        const eigen::matrix& T,
                        const eigen::matrix& W1,
                        const eigen::matrix& b1,
                        const eigen::matrix& W2,
                        const eigen::matrix& b2,
                        const eigen::matrix& W3,
                        const eigen::matrix& b3,
                        const eigen::matrix& Y1,
                        const eigen::matrix& DY1,
                        const eigen::matrix& Y2,
                        const eigen::matrix& DY2,
                        scalar lr
                       )
{
  multilayer_perceptron M;
  std::size_t K = W3.cols(); // the output size of the MLP
  std::size_t N = X.rows();  // the number of examples in the dataset
  std::size_t batch_size = N;
  construct_mlp(M, W1, b1, W2, b2, W3, b3, batch_size);

  eigen::matrix Y(N, K);
  eigen::matrix DY(N, K);

  softmax_cross_entropy_loss loss;

  M.feedforward(X, Y);
  DY = loss.gradient(Y, T) / N; // take the average of the gradients in the batch

  check_equal_matrices("Y", Y, "Y1", Y1);
  check_equal_matrices("DY", DY, "DY1", DY1);

  M.backpropagate(Y, DY);
  M.optimize(lr);
  M.feedforward(X, Y);
  M.backpropagate(Y, DY);

  check_equal_matrices("Y", Y, "Y2", Y2);
  check_equal_matrices("DY", DY, "DY2", DY2);
}

//--- begin generated code ---//
TEST_CASE("test_mlp1")
{
  eigen::matrix X {    {0.37454012, 0.95071429},
    {0.73199391, 0.59865850},
    {0.15601864, 0.15599452},
    {0.05808361, 0.86617613},
    {0.60111499, 0.70807260},
  };

  eigen::matrix T {    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {    {-0.65654379, 0.44995680},
    {-0.54210681, 0.21767996},
    {-0.52975082, -0.48508778},
    {-0.13959593, -0.47236559},
    {-0.28073224, -0.07863396},
    {-0.22755446, -0.51336354},
  };

  eigen::matrix b1 {    {0.06210625, -0.19582631, -0.29703102, -0.43231186, -0.58715391, -0.07922174},
  };

  eigen::matrix W2 {    {-0.36277333, 0.37735873, -0.05474112, -0.06183423, -0.40698171, 0.01271591},
    {-0.38363454, -0.33094659, -0.25715914, -0.39226431, 0.36112231, -0.26350960},
    {-0.33635738, -0.28601274, 0.15128762, 0.03375280, 0.16358951, -0.22497407},
    {0.26530221, 0.26543784, -0.24630447, -0.40088114, 0.40737221, 0.03591385},
  };

  eigen::matrix b2 {    {-0.11146946, 0.32005042, -0.13696676, -0.24663180},
  };

  eigen::matrix W3 {    {-0.33085376, -0.24281669, 0.16123712, 0.06306440},
    {-0.16154730, 0.41514742, 0.10048312, -0.33322221},
    {-0.10515386, -0.03567761, 0.09894884, -0.28124857},
  };

  eigen::matrix b3 {    {-0.42009276, -0.19213033, 0.10306776},
  };

  eigen::matrix Y1 {    {-0.47507846, -0.09812041, 0.09498858},
    {-0.49780634, -0.05926222, 0.09164912},
    {-0.49502444, -0.06401850, 0.09205788},
    {-0.45926774, -0.12515229, 0.09731169},
    {-0.49780634, -0.05926222, 0.09164912},
  };

  eigen::matrix DY1 {    {0.04732351, -0.13100974, 0.08368623},
    {-0.15405947, 0.07122841, 0.08283106},
    {0.04610911, -0.12904708, 0.08293797},
    {0.04829286, -0.13254915, 0.08425628},
    {0.04594053, -0.12877159, 0.08283106},
  };

  eigen::matrix Y2 {    {-0.47607353, -0.09223441, 0.09047094},
    {-0.49864605, -0.05353725, 0.08705071},
    {-0.49595129, -0.05815698, 0.08745903},
    {-0.46027496, -0.11931865, 0.09286477},
    {-0.49864605, -0.05353725, 0.08705071},
  };

  eigen::matrix DY2 {    {0.04728047, -0.13059656, 0.08331610},
    {-0.15409583, 0.07164081, 0.08245502},
    {0.04606782, -0.12862778, 0.08255996},
    {0.04825096, -0.13214506, 0.08389412},
    {0.04590418, -0.12835918, 0.08245502},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp2")
{
  eigen::matrix X {    {0.00077877, 0.99221158, 0.61748153},
    {0.61165315, 0.00706631, 0.02306242},
    {0.52477467, 0.39986098, 0.04666566},
    {0.97375554, 0.23277134, 0.09060644},
  };

  eigen::matrix T {    {0.00000000, 1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {    {-0.51908678, 0.29390815, 0.50721717},
    {-0.35566872, 0.13987175, -0.04549119},
    {-0.38882473, 0.45550764, 0.46439299},
    {-0.02804943, -0.46182877, -0.06470844},
    {-0.03999960, -0.35456771, -0.21084262},
  };

  eigen::matrix b1 {    {0.24245495, 0.28437203, 0.25161788, 0.11900228, 0.09371826},
  };

  eigen::matrix W2 {    {0.20484710, 0.33390215, -0.42709821, 0.07415365, -0.21074393},
    {-0.36095402, 0.25542265, 0.00397633, 0.08763231, 0.15866210},
  };

  eigen::matrix b2 {    {-0.33486375, 0.28175953},
  };

  eigen::matrix W3 {    {0.47378275, 0.41045383},
    {0.08417695, 0.41805223},
    {-0.27346486, 0.61870241},
    {-0.13823812, -0.14149675},
  };

  eigen::matrix b3 {    {-0.08236969, -0.02058275, -0.46297637, 0.49471354},
  };

  eigen::matrix Y1 {    {-0.04918294, 0.01321836, -0.41295195, 0.48327300},
    {0.04784682, 0.11204435, -0.26669300, 0.44982368},
    {0.03309516, 0.09701961, -0.28892905, 0.45490906},
    {0.03331403, 0.09724253, -0.28859913, 0.45483363},
  };

  eigen::matrix DY1 {    {0.05602176, -0.19037102, 0.03893802, 0.09541123},
    {0.05825870, 0.06212142, -0.20746388, 0.08708376},
    {0.05793183, 0.06175601, 0.04198207, -0.16166991},
    {0.05793671, 0.06176147, -0.20800972, 0.08831154},
  };

  eigen::matrix Y2 {    {-0.05078251, 0.01399512, -0.40838847, 0.48191160},
    {0.04593970, 0.11254934, -0.26213688, 0.44848827},
    {0.03118572, 0.09751590, -0.28444606, 0.45358664},
    {0.03139056, 0.09772463, -0.28413630, 0.45351586},
  };

  eigen::matrix DY2 {    {0.05593109, -0.19032592, 0.03911533, 0.09527948},
    {0.05814807, 0.06215320, -0.20726937, 0.08696809},
    {0.05782316, 0.06178864, 0.04217204, -0.16178383},
    {0.05782770, 0.06179373, -0.20782022, 0.08819878},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp3")
{
  eigen::matrix X {    {0.98323089, 0.46676290, 0.85994041, 0.68030757, 0.45049927, 0.01326496},
    {0.94220173, 0.56328821, 0.38541651, 0.01596625, 0.23089382, 0.24102546},
    {0.68326354, 0.60999668, 0.83319491, 0.17336465, 0.39106062, 0.18223609},
    {0.75536144, 0.42515588, 0.20794167, 0.56770033, 0.03131329, 0.84228480},
    {0.44975412, 0.39515024, 0.92665887, 0.72727197, 0.32654077, 0.57044399},
    {0.52083427, 0.96117204, 0.84453386, 0.74732012, 0.53969210, 0.58675116},
    {0.96525532, 0.60703427, 0.27599919, 0.29627350, 0.16526695, 0.01563641},
    {0.42340147, 0.39488152, 0.29348817, 0.01407982, 0.19884241, 0.71134198},
  };

  eigen::matrix T {    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
  };

  eigen::matrix W1 {    {-0.19599915, -0.18998936, 0.37579063, 0.33233231, -0.11020849, -0.40159878},
    {-0.01159491, -0.31636965, -0.17538653, -0.16899224, -0.21467870, 0.40380871},
  };

  eigen::matrix b1 {    {0.15162683, 0.08852073},
  };

  eigen::matrix W2 {    {0.67455339, -0.19713649},
    {-0.39834806, -0.37084809},
  };

  eigen::matrix b2 {    {0.23578253, 0.42356184},
  };

  eigen::matrix W3 {    {-0.13576460, 0.22138458},
    {-0.48095784, 0.22116475},
    {-0.25471994, -0.09105565},
  };

  eigen::matrix b3 {    {-0.31589738, 0.03731606, -0.45002684},
  };

  eigen::matrix Y1 {    {-0.31966463, -0.13277817, -0.59806168},
    {-0.25413823, 0.01759155, -0.54865307},
    {-0.28222752, -0.04686762, -0.56983316},
    {-0.26223102, 0.01946292, -0.53637075},
    {-0.31045067, -0.11163401, -0.59111416},
    {-0.27886373, -0.03914841, -0.56729674},
    {-0.25859529, 0.00736350, -0.55201381},
    {-0.26240477, 0.01950310, -0.53610706},
  };

  eigen::matrix DY1 {    {0.04219428, 0.05086480, -0.09305909},
    {-0.08411191, 0.05365467, 0.03045725},
    {0.04145358, 0.05245387, -0.09390745},
    {-0.08448923, 0.05369189, 0.03079734},
    {0.04201341, -0.07374540, 0.03173199},
    {0.04138628, 0.05259730, -0.09398359},
    {0.04097835, -0.07153632, 0.03055797},
    {-0.08449732, 0.05369265, 0.03080466},
  };

  eigen::matrix Y2 {    {-0.31950808, -0.13541847, -0.59651995},
    {-0.25377610, 0.01520465, -0.54715240},
    {-0.28200138, -0.04947281, -0.56835079},
    {-0.26185516, 0.01711394, -0.53494501},
    {-0.31026998, -0.11424961, -0.58958173},
    {-0.27865154, -0.04179674, -0.56583488},
    {-0.25831258, 0.00480939, -0.55055946},
    {-0.26203290, 0.01715595, -0.53467649},
  };

  eigen::matrix DY2 {    {0.04222732, 0.05076245, -0.09298977},
    {-0.08407505, 0.05355562, 0.03051943},
    {0.04148983, 0.05235130, -0.09384114},
    {-0.08445233, 0.05359456, 0.03085777},
    {0.04204711, -0.07384752, 0.03180040},
    {0.04142322, 0.05249387, -0.09391709},
    {0.04101629, -0.07163841, 0.03062211},
    {-0.08446062, 0.05359538, 0.03086523},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}


//--- end generated code ---//
