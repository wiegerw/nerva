// Copyright: Wieger Wesselink 2022 - 2024
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file multilayer_perceptron_test.cpp
/// \brief Tests for multilayer perceptrons.

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#include "doctest/doctest.h"
#include "nerva/neural_networks/multilayer_perceptron.h"
#include "nerva/neural_networks/loss_functions.h"
#include "nerva/utilities/string_utility.h"
#include <iostream>

using namespace nerva;

inline
void check_equal_matrices(const std::string& name1, const eigen::matrix& X1, const std::string& name2, const eigen::matrix& X2, scalar epsilon = 1e-5)
{
  scalar error = (X2 - X1).squaredNorm();
  if (error > epsilon)
  {
    CHECK_LE(error, epsilon);
    print_cpp_matrix(name1, X1);
    print_cpp_matrix(name2, X2);
  }
}

void construct_mlp(multilayer_perceptron& M,
                   const eigen::matrix& W1,
                   const eigen::matrix& b1,
                   const eigen::matrix& W2,
                   const eigen::matrix& b2,
                   const eigen::matrix& W3,
                   const eigen::matrix& b3,
                   std::size_t batch_size = 1
                  )
{
  std::size_t N1 = W1.cols();
  std::size_t N2 = W2.cols();
  std::size_t N3 = W3.cols();
  std::size_t N4 = W3.rows();

  auto layer1 = std::make_shared<relu_layer<eigen::matrix>>(N1, N2, batch_size);
  M.layers.push_back(layer1);
  layer1->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer1->W, layer1->DW, layer1->b, layer1->Db);
  layer1->W = W1;
  layer1->b = b1;

  auto layer2 = std::make_shared<relu_layer<eigen::matrix>>(N2, N3, batch_size);
  M.layers.push_back(layer2);
  layer2->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer2->W, layer2->DW, layer2->b, layer2->Db);
  layer2->W = W2;
  layer2->b = b2;

  auto layer3 = std::make_shared<linear_layer<eigen::matrix>>(N3, N4, batch_size);
  M.layers.push_back(layer3);
  layer3->optimizer = std::make_shared<gradient_descent_linear_layer_optimizer<eigen::matrix>>(layer3->W, layer3->DW, layer3->b, layer3->Db);
  layer3->W = W3;
  layer3->b = b3;
}

void test_mlp_execution(const eigen::matrix& X,
                        const eigen::matrix& T,
                        const eigen::matrix& W1,
                        const eigen::matrix& b1,
                        const eigen::matrix& W2,
                        const eigen::matrix& b2,
                        const eigen::matrix& W3,
                        const eigen::matrix& b3,
                        const eigen::matrix& Y1,
                        const eigen::matrix& DY1,
                        const eigen::matrix& Y2,
                        const eigen::matrix& DY2,
                        scalar lr
                       )
{
  multilayer_perceptron M;
  std::size_t K = W3.cols(); // the output size of the MLP
  std::size_t N = X.rows();  // the number of examples in the dataset
  std::size_t batch_size = N;
  construct_mlp(M, W1, b1, W2, b2, W3, b3, batch_size);

  eigen::matrix Y(K, N);
  eigen::matrix DY(K, N);

  softmax_cross_entropy_loss loss;

  M.feedforward(X, Y);
  DY = loss.gradient(Y, T) / N; // take the average of the gradients in the batch

  check_equal_matrices("Y", Y, "Y1", Y1);
  check_equal_matrices("DY", DY, "DY1", DY1);

  M.backpropagate(Y, DY);
  M.optimize(lr);
  M.feedforward(X, Y);
  M.backpropagate(Y, DY);

  check_equal_matrices("Y", Y, "Y2", Y2);
  check_equal_matrices("DY", DY, "DY2", DY2);
}

//--- begin generated code ---//
TEST_CASE("test_mlp1")
{
  eigen::matrix X {
    {0.37454012, 0.95071429},
    {0.73199391, 0.59865850},
    {0.15601864, 0.15599452},
    {0.05808361, 0.86617613},
    {0.60111499, 0.70807260},
  };

  eigen::matrix T {
    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {
    {-0.54710919, 0.01657711},
    {-0.02266834, 0.43838984},
    {-0.46234587, 0.16805786},
    {0.65977496, 0.20095381},
    {-0.64024770, -0.39307499},
    {0.70235127, 0.33024162},
  };

  eigen::matrix b1 {
    {-0.46149054},
    {-0.57363605},
    {0.18186593},
    {-0.56907070},
    {-0.69892490},
    {-0.67803717},
  };

  eigen::matrix W2 {
    {0.38319039, -0.00218680, 0.36269042, -0.29447803, 0.29729974, -0.05747246},
    {-0.36950096, 0.18689540, 0.06292705, -0.15192929, -0.26397628, -0.03296176},
    {0.30758142, -0.32210129, -0.01696526, -0.37727460, -0.33401164, 0.32895023},
    {0.24271484, -0.30816114, -0.09795181, -0.10760656, -0.15746696, -0.21852404},
  };

  eigen::matrix b2 {
    {-0.35617092},
    {-0.11346300},
    {-0.14278160},
    {0.03849121},
  };

  eigen::matrix W3 {
    {0.15170509, 0.27859747, 0.33670288, 0.19004685},
    {0.26787317, 0.40322953, -0.48545933, -0.47035486},
    {0.14302802, 0.28917533, -0.02924234, 0.41671425},
  };

  eigen::matrix b3 {
    {-0.24880016},
    {0.02204508},
    {0.10817879},
  };

  eigen::matrix Y1 {
    {-0.24462125, -0.24358703, -0.24401575, -0.24708043, -0.24191207},
    {0.01170249, 0.00914288, 0.01020394, 0.01778885, 0.00499745},
    {0.11734188, 0.11960959, 0.11866954, 0.11194962, 0.12328226},
  };

  eigen::matrix DY1 {
    {0.05364351, -0.14631528, 0.05366766, 0.05354465, 0.05375105},
    {-0.13068341, 0.06912100, -0.13079795, -0.13021736, -0.13119525},
    {0.07703991, 0.07719427, 0.07713028, 0.07667273, 0.07744420},
  };

  eigen::matrix Y2 {
    {-0.24607407, -0.24499962, -0.24546002, -0.24854831, -0.24334630},
    {0.01814710, 0.01548834, 0.01662764, 0.02426971, 0.01139718},
    {0.11179762, 0.11415315, 0.11314379, 0.10637328, 0.11777773},
  };

  eigen::matrix DY2 {
    {0.05358055, -0.14637609, 0.05360536, 0.05347980, 0.05369024},
    {-0.13021584, 0.06958042, -0.13033231, -0.12974568, -0.13073258},
    {0.07663529, 0.07679565, 0.07672694, 0.07626587, 0.07704235},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp2")
{
  eigen::matrix X {
    {0.00077877, 0.99221158, 0.61748153},
    {0.61165315, 0.00706631, 0.02306242},
    {0.52477467, 0.39986098, 0.04666566},
    {0.97375554, 0.23277134, 0.09060644},
  };

  eigen::matrix T {
    {0.00000000, 1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 0.00000000, 1.00000000, 0.00000000},
  };

  eigen::matrix W1 {
    {0.20967376, 0.22632273, -0.30660197},
    {-0.23127802, 0.13160595, -0.11594801},
    {0.14604223, -0.39548936, -0.52917576},
    {-0.44290245, 0.10574221, 0.31375515},
    {-0.03742181, 0.23280457, 0.00229313},
  };

  eigen::matrix b1 {
    {-0.45206842},
    {0.15043364},
    {0.26889998},
    {0.14413433},
    {0.00557817},
  };

  eigen::matrix W2 {
    {-0.32077140, 0.40727445, -0.26533684, 0.12343027, -0.18451758},
    {0.08971900, -0.42280176, 0.29505810, -0.18925519, -0.41355920},
  };

  eigen::matrix b2 {
    {-0.36858946},
    {-0.21711174},
  };

  eigen::matrix W3 {
    {-0.35292009, -0.52997559},
    {-0.21716340, -0.53429449},
    {-0.70222080, 0.34459162},
    {-0.08321423, -0.23901208},
  };

  eigen::matrix b3 {
    {-0.36243179},
    {-0.70133138},
    {0.11368471},
    {0.01371450},
  };

  eigen::matrix Y1 {
    {-0.36243179, -0.36243179, -0.36243179, -0.36243179},
    {-0.70133138, -0.70133138, -0.70133138, -0.70133138},
    {0.11368471, 0.11368471, 0.11368471, 0.11368471},
    {0.01371450, 0.01371450, 0.01371450, 0.01371450},
  };

  eigen::matrix DY1 {
    {0.05231193, 0.05231193, 0.05231193, 0.05231193},
    {-0.21272492, 0.03727508, 0.03727508, 0.03727508},
    {0.08421230, -0.16578770, 0.08421230, -0.16578770},
    {0.07620071, 0.07620071, -0.17379929, 0.07620071},
  };

  eigen::matrix Y2 {
    {-0.36452428, -0.36452428, -0.36452428, -0.36452428},
    {-0.70032239, -0.70032239, -0.70032239, -0.70032239},
    {0.11531622, 0.11531622, 0.11531622, 0.11531622},
    {0.01316647, 0.01316647, 0.01316647, 0.01316647},
  };

  eigen::matrix DY2 {
    {0.05219756, 0.05219756, 0.05219756, 0.05219756},
    {-0.21269087, 0.03730912, 0.03730912, 0.03730912},
    {0.08434170, -0.16565830, 0.08434170, -0.16565830},
    {0.07615164, 0.07615164, -0.17384836, 0.07615164},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}

TEST_CASE("test_mlp3")
{
  eigen::matrix X {
    {0.98323089, 0.46676290, 0.85994041, 0.68030757, 0.45049927, 0.01326496},
    {0.94220173, 0.56328821, 0.38541651, 0.01596625, 0.23089382, 0.24102546},
    {0.68326354, 0.60999668, 0.83319491, 0.17336465, 0.39106062, 0.18223609},
    {0.75536144, 0.42515588, 0.20794167, 0.56770033, 0.03131329, 0.84228480},
    {0.44975412, 0.39515024, 0.92665887, 0.72727197, 0.32654077, 0.57044399},
    {0.52083427, 0.96117204, 0.84453386, 0.74732012, 0.53969210, 0.58675116},
    {0.96525532, 0.60703427, 0.27599919, 0.29627350, 0.16526695, 0.01563641},
    {0.42340147, 0.39488152, 0.29348817, 0.01407982, 0.19884241, 0.71134198},
  };

  eigen::matrix T {
    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {1.00000000, 0.00000000, 0.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {0.00000000, 0.00000000, 1.00000000},
    {0.00000000, 1.00000000, 0.00000000},
    {1.00000000, 0.00000000, 0.00000000},
  };

  eigen::matrix W1 {
    {-0.17010491, -0.13582738, 0.39398527, -0.23187582, -0.14598054, 0.27184379},
    {-0.28631356, 0.28009000, 0.10707424, -0.03645542, 0.11532257, 0.38152239},
  };

  eigen::matrix b1 {
    {0.21469434},
    {-0.00501109},
  };

  eigen::matrix W2 {
    {0.12412938, -0.34750244},
    {0.01278533, -0.45272535},
  };

  eigen::matrix b2 {
    {-0.10945815},
    {0.10327933},
  };

  eigen::matrix W3 {
    {0.60443062, -0.32453021},
    {-0.11992296, -0.32020670},
    {0.39669693, 0.47824821},
  };

  eigen::matrix b3 {
    {-0.08446776},
    {-0.56536412},
    {0.34109318},
  };

  eigen::matrix Y1 {
    {-0.11841215, -0.11243035, -0.09456974, -0.08586842, -0.08446776, -0.08446776, -0.11798503, -0.08446776},
    {-0.59885627, -0.59295416, -0.57533151, -0.56674612, -0.56536412, -0.56536412, -0.59843487, -0.56536412},
    {0.39111578, 0.38230062, 0.35598010, 0.34315729, 0.34109318, 0.34109318, 0.39048633, 0.34109318},
  };

  eigen::matrix DY1 {
    {0.03807477, -0.08663899, 0.03921584, -0.08536780, 0.03969920, 0.03969920, 0.03809521, -0.08530080},
    {0.02354957, 0.02372473, 0.02424764, 0.02450223, -0.10045680, 0.02454320, -0.10143792, 0.02454320},
    {-0.06162435, 0.06291425, -0.06346349, 0.06086557, 0.06075760, -0.06424241, 0.06334271, 0.06075760},
  };

  eigen::matrix Y2 {
    {-0.11762752, -0.11157160, -0.09372158, -0.08498677, -0.08384253, -0.08384253, -0.11719960, -0.08384253},
    {-0.59812450, -0.59215045, -0.57454175, -0.56592506, -0.56479627, -0.56479627, -0.59770238, -0.56479627},
    {0.38968182, 0.38075852, 0.35445675, 0.34158611, 0.33990011, 0.33990011, 0.38905129, 0.33990011},
  };

  eigen::matrix DY2 {
    {0.03811798, -0.08659223, 0.03926207, -0.08532000, 0.03973474, 0.03973474, 0.03813846, -0.08526526},
    {0.02357505, 0.02375234, 0.02427480, 0.02453030, -0.10043624, 0.02456376, -0.10141242, 0.02456376},
    {-0.06169303, 0.06283989, -0.06353687, 0.06078969, 0.06070150, -0.06429850, 0.06327396, 0.06070150},
  };

  scalar lr = 0.01;
  test_mlp_execution(X, T, W1, b1, W2, b2, W3, b3, Y1, DY1, Y2, DY2, lr);
}


//--- end generated code ---//
