// Copyright: Wieger Wesselink 2023
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file nerva/neural_networks/grow.h
/// \brief add your file description here.

#ifndef NERVA_NEURAL_NETWORKS_GROW_H
#define NERVA_NEURAL_NETWORKS_GROW_H

#include <algorithm>
#include <random>
#include <stdexcept>
#include <vector>
#include "nerva/neural_networks/eigen.h"
#include "nerva/neural_networks/functions.h"
#include "nerva/neural_networks/mkl_eigen.h"
#include "nerva/neural_networks/mkl_sparse_matrix.h"
#include "nerva/neural_networks/scalar.h"
#include "nerva/neural_networks/weights.h"
#include "nerva/utilities/algorithms.h"

namespace nerva {

/// Gives \a count random accepted entries of \a A a new value generated by the function \a f.
/// In a post processing step, all NaN values are replaced by 0.
/// \tparam Function A function type
/// \param A A matrix
/// \param count The number of entries in \a A that will get a new value
/// \param f A weight initializer
/// \param rng A random number generator
/// \param accept A predicate that determines if an element may get a new value
template <typename Matrix, typename Accept=accept_zero, typename Scalar = scalar>
void grow(Matrix& A, const std::shared_ptr<weight_initializer>& init, std::size_t count, std::mt19937& rng, Accept accept=Accept())
{
  long N = A.rows() * A.cols();
  Scalar* data = A.data();

  // use reservoir sampling to randomly select count pointers to entries in A
  std::vector<Scalar*> selection;
  selection.reserve(count);

  long i = 0;
  for (; i < N; i++)
  {
    if (!accept(*(data + i)))
    {
      continue;
    }
    selection.push_back(data + i);
    if (selection.size() == count)
    {
      break;
    }
  }

  if (selection.size() != static_cast<std::size_t>(count))
  {
    auto available = std::count_if(data, data + N, accept);
    throw std::runtime_error("could not find " + std::to_string(count) + " positions in function grow; #available positions = " + std::to_string(available));
  }

  i += 1; // position i has already been handled

  for (; i < N; i++)
  {
    if (!accept(*(data + i)))
    {
      continue;
    }
    std::uniform_int_distribution<std::size_t> dist(0, i - 1);
    std::size_t j = dist(rng);
    if (j < count)
    {
      selection[j] = data + i;
    }
  }

  // assign new values to the chosen entries
  for (Scalar* x: selection)
  {
    *x = (*init)();
  }

  // replace NaN values by 0
  A = A.unaryExpr([](Scalar x) { return std::isnan(x) ? 0 : x; });
}

/// Gives \a count random accepted entries of \a A a new value generated by the function \a f
/// \tparam Scalar A number type (float of double)
/// \param A A CSR matrix
/// \param init A weight initializer. The values of added elements will be initialized using \a init.
/// \param count The number of entries that will be added
/// \param rng A random number generator
template <typename Scalar = scalar>
void grow(mkl::sparse_matrix_csr<Scalar>& A, const std::shared_ptr<weight_initializer>& init, std::size_t count, std::mt19937& rng)
{
  std::size_t N = A.rows() * A.cols();
  if (A.values().size() + count > N)
  {
    throw std::runtime_error("cannot grow the matrix with " + std::to_string(count) + " elements");
  }

  // components of the result matrix
  std::vector<MKL_INT> row_index;
  std::vector<MKL_INT> col_index;
  std::vector<Scalar> values;
  row_index.reserve(A.row_index().size());
  col_index.reserve(A.col_index().size());
  values.reserve(A.values().size());

  // Select k random new positions outside the support of A
  std::vector<std::size_t> new_positions = reservoir_sample(count, N - A.values().size(), rng);
  std::sort(new_positions.begin(), new_positions.end());  // TODO: this may become expensive for very large matrices
  auto ni = new_positions.begin();

  std::size_t traversed_elements_count = 0;

  mkl::csr_matrix_builder<Scalar> builder(A.rows(), A.cols(), A.values().size());

  // fills the result matrix until position k
  auto fill_until_index = [&](std::size_t k)
  {
    while (ni != new_positions.end() && *ni + traversed_elements_count < k)
    {
      std::size_t k1 = *ni + traversed_elements_count;
      if (k1 < k)
      {
        std::size_t i1 = k1 / A.cols();
        std::size_t j1 = k1 % A.cols();
        auto value1 = (*init)();
        builder.add_element(i1, j1, value1);
      }
      ++ni;
    }
  };

  mkl::traverse_elements(A, [&](long i, long j, Scalar value)
  {
    std::size_t k = i * A.cols() + j;
    fill_until_index(k);
    if (!std::isnan(value))
    {
      builder.add_element(i, j, value);
    }
    traversed_elements_count++;
  });

  A = builder.result();  // TODO: avoid unnecessary copies
}

} // namespace nerva

#endif // NERVA_NEURAL_NETWORKS_GROW_H
