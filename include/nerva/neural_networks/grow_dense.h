// Copyright: Wieger Wesselink 2023
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file nerva/neural_networks/grow_dense.h
/// \brief Grow functions for dense Eigen matrices.

#ifndef NERVA_NEURAL_NETWORKS_GROW_DENSE_H
#define NERVA_NEURAL_NETWORKS_GROW_DENSE_H

#include <algorithm>
#include <random>
#include <stdexcept>
#include <vector>
#include "nerva/neural_networks/eigen.h"
#include "nerva/neural_networks/functions.h"
#include "nerva/neural_networks/mkl_eigen.h"
#include "nerva/neural_networks/mkl_sparse_matrix.h"
#include "nerva/neural_networks/scalar.h"
#include "nerva/neural_networks/weights.h"
#include "nerva/utilities/algorithms.h"

namespace nerva {

/// Gives \a count random accepted entries of \a A a new value generated by the function \a f.
/// In a post processing step, all NaN values are replaced by 0.
/// \tparam Function A function type
/// \param A A matrix
/// \param count The number of entries in \a A that will get a new value
/// \param f A weight initializer
/// \param rng A random number generator
/// \param accept A predicate that determines if an element may get a new value
template <typename Matrix, typename Accept=accept_zero, typename Scalar = scalar>
void grow(Matrix& A, const std::shared_ptr<weight_initializer>& init, std::size_t count, std::mt19937& rng, Accept accept=Accept())
{
  long N = A.rows() * A.cols();
  Scalar* data = A.data();

  // use reservoir sampling to randomly select count pointers to entries in A
  std::vector<Scalar*> selection;
  selection.reserve(count);

  long i = 0;
  for (; i < N; i++)
  {
    if (!accept(*(data + i)))
    {
      continue;
    }
    selection.push_back(data + i);
    if (selection.size() == count)
    {
      break;
    }
  }

  if (selection.size() != static_cast<std::size_t>(count))
  {
    auto available = std::count_if(data, data + N, accept);
    throw std::runtime_error("could not find " + std::to_string(count) + " positions in function grow; #available positions = " + std::to_string(available));
  }

  i += 1; // position i has already been handled

  for (; i < N; i++)
  {
    if (!accept(*(data + i)))
    {
      continue;
    }
    std::uniform_int_distribution<std::size_t> dist(0, i - 1);
    std::size_t j = dist(rng);
    if (j < count)
    {
      selection[j] = data + i;
    }
  }

  // assign new values to the chosen entries
  for (Scalar* x: selection)
  {
    *x = (*init)();
  }

  // replace NaN values by 0
  A = A.unaryExpr([](Scalar x) { return std::isnan(x) ? 0 : x; });
}

} // namespace nerva

#endif // NERVA_NEURAL_NETWORKS_GROW_DENSE_H
