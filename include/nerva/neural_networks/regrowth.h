// Copyright: Wieger Wesselink 2022
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file nerva/neural_networks/regrowth.h
/// \brief Algorithms for pruning and growing sparse matrices.

#ifndef NERVA_NEURAL_NETWORKS_REGROWTH_H
#define NERVA_NEURAL_NETWORKS_REGROWTH_H

#include "nerva/neural_networks/mkl_matrix.h"
#include "nerva/neural_networks/weights.h"
#include <algorithm>
#include <random>
#include <vector>

namespace nerva {

/// Returns the absolute value of the k-th smallest non-zero entry in the matrix \a A
/// \param A A matrix
/// \param k A positive number
/// \return The k-th smallest entry
template <typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
scalar find_k_smallest_value(const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, long k)
{
  assert(k > 0);
  long N = A.rows() * A.cols();
  const scalar* data = A.data();

  auto is_zero = [&data](long i)
  {
    return *(data + i) == scalar(0);
  };

  // copy the non-zero entries of A
  std::vector<scalar> values;
  for (long i = 0; i < N; i++)
  {
    if (!is_zero(i))
    {
      values.push_back(std::fabs(data[i]));
    }
  }

  auto kth_element = values.begin() + k - 1;
  std::nth_element(values.begin(), kth_element, values.end());
  return *kth_element;
}

/// Sets all non-zero entries `i,j` in \a A with `A[i,j] <= threshold` to zero
/// \param A A matrix
/// \param threshold A threshold value
/// \return The number of entries that were set to zero
template <typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
long prune(Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, scalar threshold)
{
  long N = A.rows() * A.cols();
  scalar* data = A.data();

  auto is_zero = [&data](long i)
  {
    return *(data + i) == scalar(0);
  };

  long count = 0;
  for (long i = 0; i < N; i++)
  {
    if (is_zero(i))
    {
      continue;
    }
    if (std::fabs(data[i]) <= threshold)
    {
      data[i] = scalar(0);
      count++;
    }
  }
  return count;
}

/// Gives \a k random zero entries of \a A a new value generated by the function \a f
/// \tparam Function A function type
/// \param A A matrix
/// \param f A function that generates new values
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator

template <typename Function, typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
void grow(Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, Function f, long k, std::mt19937& rng)
{
  long N = A.rows() * A.cols();
  scalar* data = A.data();

  // use reservoir sampling to randomly select k pointers to zero-entries in A
  std::vector<scalar*> selection;
  selection.reserve(k);

  auto is_zero = [&data](long i)
  {
    return *(data + i) == scalar(0);
  };

  long i = 0;
  for (; i < N; i++)
  {
    if (!is_zero(i))
    {
      continue;
    }
    selection.push_back(data + i);
    if (selection.size() == k)
    {
      break;
    }
  }

  for (; i < N; i++)
  {
    if (!is_zero(i))
    {
      continue;
    }
    std::uniform_int_distribution<long> dist(0, i - 1);
    long j = dist(rng);
    if (j < k)
    {
      selection[j] = data + i;
    }
  }

  // assign new values to the chosen entries
  for (scalar* x: selection)
  {
    *x = f();
  }
}

/// Prunes and grows the \a k smallest elements of the matrix \a A
/// \tparam Function A function type
/// \tparam Scalar A number type
/// \param A A matrix
/// \param f A function that generates new values
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator
template <typename Function, typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
void regrow(Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, Function f, long k, std::mt19937& rng)
{
  scalar threshold = find_k_smallest_value(A, k);
  prune(A, threshold);
  grow(A, f, k, rng);
}

/// Prunes and grows the \a k smallest elements of the matrix \a A.
///
/// N.B. This implementation is not very efficient!
/// \tparam Function
/// \tparam Scalar A number type
/// \param A A matrix
/// \param f A function that generates new values
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator
template <typename Function, typename Scalar = scalar>
void regrow(mkl::sparse_matrix_csr<Scalar>& A, Function f, long k, std::mt19937& rng)
{
  auto A1 = mkl::to_eigen(A);
  regrow(A1, f, k, rng);
  A = mkl::to_csr(A1);
}

// mkl::sparse_matrix_csr<Scalar>& A

} // namespace nerva

#endif // NERVA_NEURAL_NETWORKS_REGROWTH_H
