// Copyright: Wieger Wesselink 2022
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file nerva/neural_networks/regrowth.h
/// \brief Algorithms for pruning and growing sparse matrices.

#ifndef NERVA_NEURAL_NETWORKS_REGROWTH_H
#define NERVA_NEURAL_NETWORKS_REGROWTH_H

#include "nerva/neural_networks/mkl_sparse_matrix.h"
#include "nerva/neural_networks/layers.h"
#include "nerva/neural_networks/weights.h"
#include <algorithm>
#include <memory>
#include <random>
#include <vector>

namespace nerva {

struct accept_zero
{
  template <typename T>
  bool operator()(T x) const
  {
    return x == 0;
  }
};

struct accept_nonzero
{
  template <typename T>
  bool operator()(T x) const
  {
    return x != 0;
  }
};

struct accept_negative
{
  template <typename T>
  bool operator()(T x) const
  {
    return x < 0;
  }
};

struct accept_positive
{
  template <typename T>
  bool operator()(T x) const
  {
    return x > 0;
  }
};

template <typename Scalar>
struct accept_value
{
  Scalar value;

  explicit accept_value(Scalar value_)
   : value(value_)
  {}

  bool operator()(Scalar x) const
  {
    return x == value;
  }
};

struct compare_less_absolute
{
  template <typename T>
  bool operator()(T x, T y) const
  {
    return std::fabs(x) < std::fabs(y);
  }
};

/// Generic version of `std::nth_element` applied to accepted elements of an Eigen matrix.
/// \param A a matrix
/// \param k an index in the range `0, ..., A.size() - 1)`
/// \param accept a predicate function; only values \c x for which `accept(x) == true` are considered
/// \param comp comparison function object
/// \return A pair `(value, m)` with \c value the value of the element with index \c n, if the elements were
/// sorted according to \c comp, and \c m the number of accepted elements equal to \c value in the range `0, ..., k-1`.
template <typename EigenMatrix, typename Accept=accept_nonzero, typename Scalar = scalar, typename Compare = std::less<Scalar>>
std::pair<scalar, unsigned int> nth_element(const EigenMatrix& A, long k, Accept accept = Accept(), Compare comp = Compare())
{
  long N = A.rows() * A.cols();
  const Scalar* data = A.data();

  // copy the non-zero entries of A
  std::vector<Scalar> values;
  for (long i = 0; i < N; i++)
  {
    auto value = data[i];
    if (accept(value))
    {
      values.push_back(value);
    }
  }

  auto kth_element = values.begin() + k;
  std::nth_element(values.begin(), kth_element, values.end(), comp);

  Scalar value = *kth_element;
  unsigned int num_copies = 1 + std::count_if(values.begin(), kth_element, [value, comp](Scalar x) { return !comp(x, value); });
  return {value, num_copies};
}

/// Overwrites entries `A[i,j]` that satisfy the predicate \a accept with another value
/// \param A A matrix
/// \param accept A predicate that determines if an element is pruned
/// \param value The value that is assigned to pruned elements
/// \return The number of entries that were pruned
template <typename EigenMatrix, typename Accept>
long prune(EigenMatrix& A, Accept accept, scalar value = 0)
{
  long N = A.rows() * A.cols();
  scalar* data = A.data();

  long count = 0;
  for (long i = 0; i < N; i++)
  {
    if (accept(data[i]))
    {
      data[i] = value;
      count++;
    }
  }
  return count;
}

/// Gives \a count random accepted entries of \a A a new value generated by the function \a f
/// \tparam Function A function type
/// \param A A matrix
/// \param count The number of entries in \a A that will get a new value
/// \param f A weight initializer
/// \param rng A random number generator
/// \param accept A predicate that determines if an element may get a new value
template <typename EigenMatrix, typename Accept=accept_zero, typename Scalar = scalar>
void grow(EigenMatrix& A, const std::shared_ptr<weight_initializer>& init, long count, std::mt19937& rng, Accept accept=Accept())
{
  long N = A.rows() * A.cols();
  Scalar* data = A.data();

  // use reservoir sampling to randomly select count pointers to entries in A
  std::vector<Scalar*> selection;
  selection.reserve(count);

  long i = 0;
  for (; i < N; i++)
  {
    if (!accept(*(data + i)))
    {
      continue;
    }
    selection.push_back(data + i);
    if (static_cast<long>(selection.size()) == count)
    {
      break;
    }
  }

  if (selection.size() != static_cast<std::size_t>(count))
  {
    auto available = std::count_if(data, data + N, accept);
    throw std::runtime_error("could not find " + std::to_string(count) + " positions in function grow; #available positions = " + std::to_string(available));
  }

  i += 1; // position i has already been handled

  for (; i < N; i++)
  {
    if (!accept(*(data + i)))
    {
      continue;
    }
    std::uniform_int_distribution<long> dist(0, i - 1);
    long j = dist(rng);
    if (j < count)
    {
      selection[j] = data + i;
    }
  }

  // assign new values to the chosen entries
  for (Scalar* x: selection)
  {
    *x = (*init)();
  }
}

// Remove the smallest count nonzero elements (in absolute size) and randomly add new elements for them.
// N.B. This function must accept both Eigen::Matrix and Eigen::Ref<Eigen::Matrix>>.
template <typename EigenMatrix, typename Scalar = scalar>
void regrow_threshold(EigenMatrix& W, const std::shared_ptr<weight_initializer>& init, long count, std::mt19937& rng)
{
  assert(count > 0);

  Scalar threshold;
  unsigned long num_copies;   // the number of copies of threshold that should be accepted
  std::tie(threshold, num_copies) = nth_element(W, count - 1, accept_nonzero(), compare_less_absolute());
  threshold = std::fabs(threshold);
  Scalar max_scalar = std::numeric_limits<Scalar>::max();

  // Accepts values x with 0 < |x| <= threshold.
  // At most num_copies elements with |x| == threshold are accepted.
  auto accept = [threshold, &num_copies](Scalar x)
  {
    auto x_ = std::fabs(x);
    if (0 != x_ && x_ <= threshold)
    {
      if (std::fabs(x) == threshold)
      {
        if (num_copies > 0)
        {
          num_copies--;
          return true;
        }
        return false;
      }
      return true;
    }
    return false;
  };

  // prune elements by giving them the value max_scalar
  long prune_count = prune(W, accept, max_scalar);

  assert(prune_count == count);

  // grow elements that are equal to zero
  grow(W, init, prune_count, rng, accept_zero());

  // replace max_scalar by 0
  W = W.unaryExpr([max_scalar](scalar x) { return x == max_scalar ? 0 : x; });
}

/// Prunes and regrows a given fraction of the smallest elements (in absolute value) of the matrix \a W.
/// \param W A sparse matrix
/// \param zeta The fraction of entries in \a W that will get a new value
/// \param rng A random number generator
template <typename Scalar = scalar>
void regrow_threshold(mkl::sparse_matrix_csr<Scalar>& W, const std::shared_ptr<weight_initializer>& init, scalar zeta, std::mt19937& rng)
{
  eigen::matrix W1 = mkl::to_eigen(W);
  long nonzero_count = (W1.array() != 0).count();
  long count = std::lround(zeta * static_cast<scalar>(nonzero_count));
  regrow_threshold(W1, init, count, rng);
  W = mkl::to_csr(W1);
}

template <typename EigenMatrix, typename Scalar = scalar>
void regrow_interval(EigenMatrix& W, const std::shared_ptr<weight_initializer>& init, long negative_count, long positive_count, std::mt19937& rng)
{
  assert(negative_count > 0);
  assert(positive_count > 0);

  Scalar threshold_negative;
  unsigned long num_copies_negative;
  Scalar threshold_positive;
  unsigned long num_copies_positive;
  std::tie(threshold_negative, num_copies_negative) = nth_element(W, negative_count - 1, accept_negative(), std::greater<>());  // TODO: use structured bindings when moving to C++20
  std::tie(threshold_positive, num_copies_positive) = nth_element(W, positive_count - 1, accept_positive());
  Scalar max_scalar = std::numeric_limits<Scalar>::max();

  // Accepts values x with `threshold_negative <= x < 0` or `0 < x <= threshold_positive`.
  // At most num_copies_negative elements with x == threshold_negative are accepted.
  // At most num_copies_positive elements with x == threshold_positive are accepted.
  auto accept = [threshold_negative, threshold_positive, &num_copies_negative, &num_copies_positive](Scalar x)
  {
    if (x < 0 && threshold_negative <= x)
    {
      if (x == threshold_negative)
      {
        return num_copies_negative-- > 0;
      }
      return true;
    }
    else if (x > 0 && x <= threshold_positive)
    {
      if (x == threshold_positive)
      {
        return num_copies_positive-- > 0;
      }
      return true;
    }
    return false;
  };

  // prune elements by giving them the value max_scalar
  long prune_count = prune(W, accept, max_scalar);

  assert(prune_count == negative_count + positive_count);

  // grow elements that are equal to zero
  grow(W, init, prune_count, rng, accept_zero());

  // replace max_scalar by 0
  W = W.unaryExpr([max_scalar](Scalar x) { return x == max_scalar ? 0 : x; });
}

/// Prunes and regrows a given fraction of the smallest elements of matrix \a W.
/// Positive and negative entries are pruned independently.
/// \param W A sparse matrix
/// \param zeta The fraction of positive and negative entries in \a W that will get a new value
/// \param rng A random number generator
template <typename Scalar = scalar>
void regrow_interval(mkl::sparse_matrix_csr<Scalar>& W, const std::shared_ptr<weight_initializer>& init, scalar zeta, std::mt19937& rng)
{
  auto W1 = mkl::to_eigen(W);
  long negative_count = std::lround(zeta * (W1.array() < 0).count());
  long positive_count = std::lround(zeta * (W1.array() > 0).count());
  regrow_interval(W1, init, negative_count, positive_count, rng);
  W = mkl::to_csr(W1);
}

template <typename Matrix>
std::shared_ptr<weight_initializer> create_weight_initializer(const Matrix& W, weight_initialization w, std::mt19937& rng)
{
  switch(w)
  {
    case weight_initialization::he: return std::make_shared<he_weight_initializer>(rng, W.cols());
    case weight_initialization::xavier: return std::make_shared<xavier_weight_initializer>(rng, W.cols());
    case weight_initialization::xavier_normalized: return std::make_shared<xavier_normalized_weight_initializer>(rng, W.rows(), W.cols());
    case weight_initialization::zero: return std::make_shared<zero_weight_initializer>(rng);
    case weight_initialization::ten: return std::make_shared<ten_weight_initializer>(rng);
    default: return std::make_shared<uniform_weight_initializer>(rng);
  }
}

/// Prunes and regrows a given fraction of the smallest elements of matrix \a W.
/// Positive and negative entries are pruned independently.
/// \param W A sparse matrix
/// \param zeta The fraction of positive and negative entries in \a W that will get a new value
/// \param rng A random number generator
template <typename Scalar = scalar>
void regrow(sparse_linear_layer& layer, weight_initialization w, scalar zeta, bool separate_positive_negative, std::mt19937& rng)
{
  auto init = create_weight_initializer(layer.W, w, rng);
  if (separate_positive_negative)
  {
    regrow_interval(layer.W, init, zeta, rng);
  }
  else
  {
    regrow_threshold(layer.W, init, zeta, rng);
  }
  layer.reset_support();
}

} // namespace nerva

#endif // NERVA_NEURAL_NETWORKS_REGROWTH_H
