// Copyright: Wieger Wesselink 2022
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file nerva/neural_networks/regrowth.h
/// \brief Algorithms for pruning and growing sparse matrices.

#ifndef NERVA_NEURAL_NETWORKS_REGROWTH_H
#define NERVA_NEURAL_NETWORKS_REGROWTH_H

#include "nerva/neural_networks/mkl_matrix.h"
#include "nerva/neural_networks/weights.h"
#include <algorithm>
#include <random>
#include <vector>

namespace nerva {

/// Returns the absolute value of the k-th smallest non-zero entry in the matrix \a A
/// \param A A matrix
/// \param k A positive number
/// \return The k-th smallest entry
template <typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
scalar find_k_smallest_value(const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, long k)
{
  assert(k > 0);
  long N = A.rows() * A.cols();
  const scalar* data = A.data();

  auto is_zero = [&data](long i)
  {
    return *(data + i) == scalar(0);
  };

  // copy the non-zero entries of A
  std::vector<scalar> values;
  for (long i = 0; i < N; i++)
  {
    if (!is_zero(i))
    {
      values.push_back(std::fabs(data[i]));
    }
  }

  auto kth_element = values.begin() + k - 1;
  std::nth_element(values.begin(), kth_element, values.end());
  return *kth_element;
}

/// Sets all non-zero entries `i,j` in \a A with `A[i,j] <= threshold` to zero
/// \param A A matrix
/// \param threshold A threshold value
/// \return The number of entries that were set to zero
template <typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
long prune(Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, scalar threshold)
{
  long N = A.rows() * A.cols();
  scalar* data = A.data();

  auto is_zero = [&data](long i)
  {
    return *(data + i) == scalar(0);
  };

  long count = 0;
  for (long i = 0; i < N; i++)
  {
    if (is_zero(i))
    {
      continue;
    }
    if (std::fabs(data[i]) <= threshold)
    {
      data[i] = scalar(0);
      count++;
    }
  }
  return count;
}

/// Gives \a k random zero entries of \a A a new value generated by the function \a f
/// \tparam Function A function type
/// \param A A matrix
/// \param f A function that generates new values
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator

template <typename Function, typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
void grow(Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, Function f, long k, std::mt19937& rng)
{
  long N = A.rows() * A.cols();
  scalar* data = A.data();

  // use reservoir sampling to randomly select k pointers to zero-entries in A
  std::vector<scalar*> selection;
  selection.reserve(k);

  auto is_zero = [&data](long i)
  {
    return *(data + i) == scalar(0);
  };

  long i = 0;
  for (; i < N; i++)
  {
    if (!is_zero(i))
    {
      continue;
    }
    selection.push_back(data + i);
    if (selection.size() == k)
    {
      break;
    }
  }

  for (; i < N; i++)
  {
    if (!is_zero(i))
    {
      continue;
    }
    std::uniform_int_distribution<long> dist(0, i - 1);
    long j = dist(rng);
    if (j < k)
    {
      selection[j] = data + i;
    }
  }

  // assign new values to the chosen entries
  for (scalar* x: selection)
  {
    *x = f();
  }
}

/// Prunes and grows the \a k smallest elements of the matrix \a A
/// \tparam Function A function type
/// \tparam Scalar A number type
/// \param A A matrix
/// \param f A function that generates new values
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator
template <typename Function, typename Scalar = scalar, int MatrixLayout = eigen::default_matrix_layout>
void regrow(Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, MatrixLayout>& A, Function f, long k, std::mt19937& rng)
{
  scalar threshold = find_k_smallest_value(A, k);
  prune(A, threshold);
  grow(A, f, k, rng);
}

/// Prunes and grows the \a k smallest elements of the matrix \a W.
///
/// N.B. This implementation is not very efficient!
/// \tparam Function
/// \tparam Scalar A number type
/// \param W A matrix
/// \param f A function that generates new values
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator
template <typename Function, typename Scalar = scalar>
void regrow(mkl::sparse_matrix_csr<Scalar>& W, Function f, long k, std::mt19937& rng)
{
  auto W1 = mkl::to_eigen(W);
  regrow(W1, f, k, rng);
  W = mkl::to_csr(W1);
}

inline
void check_pruning(const eigen::matrix& W0, const eigen::matrix& W1, scalar threshold)
{
  long m = W0.rows();
  long n = W0.cols();

  long count = 0;
  for (long i = 0; i < m; i++)
  {
    for (long j = 0; j < n; j++)
    {
      if (W0(i, j) != W1(i, j))
      {
        if (W0(i, j) != scalar(0) && std::fabs(W0(i, j)) <= threshold && W1(i, j) == scalar(0))
        {
          count++;
        }
        else
        {
          throw std::runtime_error("check_pruning: W[" + std::to_string(i) + "," + std::to_string(j) + "] was modified unexpectedly.");
        }
      }
    }
  }
  std::cout << count << " weights were pruned" << std::endl;
}

inline
void check_growing(const eigen::matrix& W0, const eigen::matrix& W1)
{
  long m = W0.rows();
  long n = W0.cols();

  long grow_count = 0;
  for (long i = 0; i < m; i++)
  {
    for (long j = 0; j < n; j++)
    {
      if (W0(i, j) != W1(i, j))
      {
        if (W0(i, j) == scalar(0) && W1(i, j) != 0)
        {
          grow_count++;
        }
        else
        {
          throw std::runtime_error("check_growing: W[" + std::to_string(i) + "," + std::to_string(j) + "] was modified unexpectedly.");
        }
      }
    }
  }
  std::cout << grow_count << " weights were regrown" << std::endl;
}

/// Prunes and grows the \a k smallest elements of the matrix \a W.
/// \tparam Scalar A number type
/// \param W A matrix
/// \param w A weight initialization
/// \param k The number of zero entries in \a A that will get a new value
/// \param rng A random number generator
template <typename Scalar = scalar>
void regrow(mkl::sparse_matrix_csr<Scalar>& W, weight_initialization w, long k, std::mt19937& rng, bool check=false)
{
  auto W1 = mkl::to_eigen(W);

  scalar threshold = find_k_smallest_value(W1, k);
  prune(W1, threshold);

  eigen::matrix Wpruned;
  if (check)
  {
    auto W0 = mkl::to_eigen(W);
    Wpruned = W1;
    check_pruning(W0, Wpruned, threshold);
  }

  switch(w)
  {
    case weight_initialization::he:
    {
      he_weight_initializer init(rng, W.cols());
      grow(W1, init, k, rng);
      break;
    }
    case weight_initialization::xavier:
    {
      xavier_weight_initializer init(rng, W.cols());
      grow(W1, init, k, rng);
      break;
    }
    case weight_initialization::xavier_normalized:
    {
      xavier_normalized_weight_initializer init(rng, W.rows(), W.cols());
      grow(W1, init, k, rng);
      break;
    }
    case weight_initialization::uniform:
    case weight_initialization::default_:
    case weight_initialization::pytorch:
    case weight_initialization::tensorflow:
    {
      uniform_weight_initializer init(rng);
      grow(W1, init, k, rng);
      break;
    }
    case weight_initialization::zero:
    {
      zero_weight_initializer init(rng);
      grow(W1, init, k, rng);
      break;
    }
  }

  if (check)
  {
    auto W0 = mkl::to_eigen(W);
    check_growing(Wpruned, W1);
  }
  W = mkl::to_csr(W1);
}

} // namespace nerva

#endif // NERVA_NEURAL_NETWORKS_REGROWTH_H
